---
title: "Meta-compilation of Baseline JIT Compilers with Druid"
numpages: 44
type: "article"
doi: "10.22152/programming-journal.org/2026/10/9"
number: "9"
volume: "10"
issue: "1"
id: "urn:doi:10.22152%2Fprogramming-journal.org%2F2026%2F10%2F9"
date: "2025-02-15"
authors: 
  - name: "Palumbo, Nahuel"
    affiliation: "University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France"
    id: "0009-0001-5004-5632"

  - name: "Polito, Guillermo"
    affiliation: "University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France"
    id: "0000-0003-0813-8584"

  - name: "Ducasse, Stéphane"
    affiliation: "University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France"
    id: "0000-0001-6070-6599"

  - name: "Tesone, Pablo"
    affiliation: "University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France"
    id: "0000-0002-5615-6691?"

arxiv: "2502.20543"
file: "https://arxiv.org/pdf/2502.20543v1.pdf"
excerpt: |
    Virtual Machines (VMs) combine interpreters and just-in-time (JIT) compiled code to achieve good performance.
    However, implementing different execution engines increases the cost of developing and maintaining such solutions.
    JIT compilers based on meta-compilation cope with these issues by automatically generating optimizing JIT compilers.
    This leaves open the question of how meta-compilation applies to baseline JIT compilers, which improve warmup times by trading off optimizations.
    
    In this paper, we present Druid, an ahead-of-time automatic approach to generate baseline JIT compiler frontends from interpreters.
    Language developers guide meta-compilation by annotating interpreter code and using Druid's intrinsics.
    Druid targets the meta-compilation to an existing JIT compiler infrastructure to achieve good warm-up performance.
    
    We applied Druid in the context of the Pharo programming language and evaluated it by comparing an autogenerated JIT compiler frontend against the one in production for more than 10 years.
    Our generated JIT compiler frontend is 2x faster on average than the interpreter and achieves on average 0.7x the performance of the handwritten JIT compiler.
    Our experiment only required changes in 60 call sites in the interpreter, showing that our solution makes language VMs **easier to maintain and evolve in the long run**.

---
Nahuel Palumbo[^1] [![OrcidLogo]](https://orcid.org/0009-0001-5004-5632), Guillermo Polito[^2] [![OrcidLogo]](https://orcid.org/0000-0003-0813-8584), Stéphane Ducasse[^3] [![OrcidLogo]](https://orcid.org/0000-0001-6070-6599), and Pablo Tesone[^4] [![OrcidLogo]](https://orcid.org/0000-0002-5615-6691?)

The Art, Science, and Engineering of Programming, 2025, Vol. 10, Issue 1, Article 9

Submission date: 2024-09-30  
Publication date: 2025-02-15  
DOI: <https://doi.org/10.22152/programming-journal.org/2026/10/9>  
Full text: [PDF](https://arxiv.org/pdf/2502.20543v1.pdf)  


### Abstract

Virtual Machines (VMs) combine interpreters and just-in-time (JIT) compiled code to achieve good performance.
However, implementing different execution engines increases the cost of developing and maintaining such solutions.
JIT compilers based on meta-compilation cope with these issues by automatically generating optimizing JIT compilers.
This leaves open the question of how meta-compilation applies to baseline JIT compilers, which improve warmup times by trading off optimizations.

In this paper, we present Druid, an ahead-of-time automatic approach to generate baseline JIT compiler frontends from interpreters.
Language developers guide meta-compilation by annotating interpreter code and using Druid's intrinsics.
Druid targets the meta-compilation to an existing JIT compiler infrastructure to achieve good warm-up performance.

We applied Druid in the context of the Pharo programming language and evaluated it by comparing an autogenerated JIT compiler frontend against the one in production for more than 10 years.
Our generated JIT compiler frontend is 2x faster on average than the interpreter and achieves on average 0.7x the performance of the handwritten JIT compiler.
Our experiment only required changes in 60 call sites in the interpreter, showing that our solution makes language VMs **easier to maintain and evolve in the long run**.


[^1]: University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France  
    [![OrcidLogo]](https://orcid.org/0009-0001-5004-5632) <https://orcid.org/0009-0001-5004-5632>

[^2]: University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France  
    [![OrcidLogo]](https://orcid.org/0000-0003-0813-8584) <https://orcid.org/0000-0003-0813-8584>

[^3]: University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France  
    [![OrcidLogo]](https://orcid.org/0000-0001-6070-6599) <https://orcid.org/0000-0001-6070-6599>

[^4]: University of Lille - Inria - CNRS - Centrale Lille - UMR 9189 CRIStAL, France  
    [![OrcidLogo]](https://orcid.org/0000-0002-5615-6691?) <https://orcid.org/0000-0002-5615-6691?>


[OrcidLogo]: /assets/images/orcid.svg "Orcid Logo"
{: style="vertical-align: top" height="16"}
